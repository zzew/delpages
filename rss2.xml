<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DOOKNET.Blog</title>
    <link>https://DOOKNET.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>但行好事，莫问前程</description>
    <pubDate>Mon, 23 Apr 2018 12:16:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>OneNote使用笔记</title>
      <link>https://DOOKNET.github.io/2018/04/23/OneNote%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</link>
      <guid>https://DOOKNET.github.io/2018/04/23/OneNote%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Mon, 23 Apr 2018 08:51:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;之前很长一段时间用OneNote记笔记，但是发现它的同步是个问题，老是同步出错，也一直解决不了。后来慢慢开始用有道云笔记记东西（主要
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>之前很长一段时间用OneNote记笔记，但是发现它的同步是个问题，老是同步出错，也一直解决不了。后来慢慢开始用有道云笔记记东西（主要是能写markdown），然后OneNote搁置到现在。</p><p>最近突然又想用OneNote来记东西了（主要是因为颜值高，真心觉得有道云笔记太丑了，奈何我又是颜控），虽然同步有问题，但把笔记写在本地，不用同步，体验还是不错的。下面主要是我在使用过程中遇到的问题。</p><h2 id="1-关于OneNote不同版本的问题"><a href="#1-关于OneNote不同版本的问题" class="headerlink" title="1. 关于OneNote不同版本的问题"></a>1. 关于OneNote不同版本的问题</h2><p>目前我电脑里有两个版本的OneNote，一个是win10自带的OneNote，另一个是OneNote 2016.</p><p><img src="https://user-images.githubusercontent.com/29295862/39125645-423717f2-4732-11e8-916f-aab47058000c.png" alt="两个OneNote"></p><p>简单来说，自带的OneNote功能相对少一些，但也是够用的。只有在某些场合下功能受限，比如：新建笔记本等。</p><p>就我个人而言，更喜欢自带的OneNote，整个UI风格，交互设计可以说是非常符合我的口味。而OneNote 2016的界面和word很像，整体来说也还是不错的。</p><h2 id="2-如何新建笔记本"><a href="#2-如何新建笔记本" class="headerlink" title="2. 如何新建笔记本"></a>2. 如何新建笔记本</h2><p>如上面所说，新建笔记本这个操作在自带的OneNote里是不能实现的，需要用OneNote 2016来实现。</p><p>笔记本一共有两种，一种是云端笔记本，另一种是本地笔记本。</p><ul><li><p>新建云端笔记本</p><p>  【文件 — 新建 — OneDrive-个人】</p><p>  <img src="https://user-images.githubusercontent.com/29295862/39125630-31820692-4732-11e8-9dcc-315e513991e8.png" alt="新建云端笔记"></p><p>  <img src="https://user-images.githubusercontent.com/29295862/39125633-3475f39a-4732-11e8-8d07-4d96a576944a.png" alt="新建云端笔记"></p></li><li><p>新建本地笔记本</p><p>  【文件 — 新建 — 这台电脑】</p><p>  <img src="https://user-images.githubusercontent.com/29295862/39125642-3c52b508-4732-11e8-8839-c4b4764f5379.png" alt="新建本地笔记本"></p></li></ul><h2 id="3-如何同步本地笔记本"><a href="#3-如何同步本地笔记本" class="headerlink" title="3. 如何同步本地笔记本"></a>3. 如何同步本地笔记本</h2><p>在【文件 — 信息】里找到要同步的本地的笔记本，点击旁边的【设置 — 共享或移动】，就能把本地笔记本搬移到云端，这里需要注意的是搬移到云端的笔记本和本地笔记本虽然名字一样但已经没有关系了，属于两个独立的笔记本了。</p><p>另外说一下如何区分云端和本地的笔记本，如下图：</p><p><img src="https://user-images.githubusercontent.com/29295862/39125643-4025f5fa-4732-11e8-9199-1f88320dcc98.png" alt="云端和本地"></p><h2 id="4-如何删除笔记本"><a href="#4-如何删除笔记本" class="headerlink" title="4. 如何删除笔记本"></a>4. 如何删除笔记本</h2><p>和新建笔记本一样，分为云端和本地两种</p><ul><li><p>删除云端笔记本</p><p>  这个操作并不能在软件里实现，需要配合网页的云端进行。</p><p>  简单来说，先登陆网页版的OneDrive，删除选择的笔记本，然后在客户端【文件 — 信息 — 设置】里点击关闭。这时候你再【打开】笔记本你会发现原笔记本已经没有了。（这两者的先后顺序不影响）</p></li><li><p>删除本地笔记本</p><p>  和云端的操作类似，先在本地把对应笔记本的文件夹删除，一般在【C:\Users\用户名\Documents\OneNote 笔记本】下，然后再点击【关闭】对应的笔记本。</p></li></ul><hr><h1 id="嗯，就酱！"><a href="#嗯，就酱！" class="headerlink" title="嗯，就酱！"></a>嗯，就酱！</h1>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/04/23/OneNote%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>关于乘法器的那些事</title>
      <link>https://DOOKNET.github.io/2018/02/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
      <guid>https://DOOKNET.github.io/2018/02/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
      <pubDate>Mon, 26 Feb 2018 13:07:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;一、整数乘法器&quot;&gt;&lt;a href=&quot;#一、整数乘法器&quot; class=&quot;headerlink&quot; title=&quot;一、整数乘法器&quot;&gt;&lt;/a&gt;一、整数乘法器&lt;/h1&gt;&lt;h2 id=&quot;1-1-整数的概念&quot;&gt;&lt;a href=&quot;#1-1-整数的概念&quot; class=&quot;header
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="一、整数乘法器"><a href="#一、整数乘法器" class="headerlink" title="一、整数乘法器"></a>一、整数乘法器</h1><h2 id="1-1-整数的概念"><a href="#1-1-整数的概念" class="headerlink" title="1.1 整数的概念"></a>1.1 整数的概念</h2><p>整数在<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E6%B0%94%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BC%9A" target="_blank" rel="noopener">IEEE</a>的规定上有，短整数 short integer ，中整数 integer 和 长整数 long integer ，他们之间的关系如下：</p><table><thead><tr><th style="text-align:center">整数</th><th style="text-align:center">字节空间</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">  短整数</td><td style="text-align:center">一个字节</td><td style="text-align:center">-127 ~ 127</td></tr><tr><td style="text-align:center">  整数</td><td style="text-align:center">二个字节</td><td style="text-align:center">-32767~32767</td></tr><tr><td style="text-align:center">  长整数</td><td style="text-align:center">四个字节</td><td style="text-align:center">-2147483647~2147483647</td></tr></tbody></table><p>若无特殊说明，以下都以短整数举例。</p><p><strong>四个结论：</strong></p><ul><li>短整数的最高位是符号位，正值的符号位是“0”，负值的符号位是“1”。</li><li>正值用原码表示，负值用补码表示。</li><li>正值(8’b0000_0100)“取反加一”就得到负值(8’b1111_1100) ； 同理，负值(8’b1111_1100)“取反加一”就得到正值(b’b0000_0100)。</li><li>8’b1000_0000既不是正数也不是负数也不是0，它是划分正值和负值的边界线。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+4   即 8&apos;b0000_0100;</span><br><span class="line">+127 即 8&apos;b0111_1111;</span><br><span class="line">分界线  8&apos;b1000_0000;</span><br><span class="line">-127 即 8&apos;b1000_0001;</span><br><span class="line">-4   即 8&apos;b1111_1100;</span><br></pre></td></tr></table></figure><h2 id="1-2-传统乘法器"><a href="#1-2-传统乘法器" class="headerlink" title="1.2 传统乘法器"></a>1.2 传统乘法器</h2><p>在传统概念上，乘法等价于“重复几次”，也就是累加操作。比如：B=4,那么A x B等价于A重复加四次。那如果B=-4应该怎么理解呢？<br>先来看一组例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A x B = C；</span><br><span class="line">3 x 4 = 12;</span><br><span class="line">-3x 4 = -12;</span><br><span class="line">3 x-4 = -12;</span><br><span class="line">-3x-4 = 12;</span><br></pre></td></tr></table></figure></p><p>其中，C的值可以看成由两部分构成：正负和数值。</p><p>撇开正负不看，乘积的数值就是A和B绝对值相乘的结果。那么乘积的正负如何确定呢？</p><p>其实正负号的运算规则和数字电路中的“异或运算”一样。</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C(A⊕B)</th></tr></thead><tbody><tr><td style="text-align:center">  0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">  0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">  1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">  1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>其中，0表示正号，1表示负号。</p><p>因此，传统乘法器实现的大致操作如下：</p><ol><li>在初始化之际，取乘数和被乘数的正负关系,然后取乘数和被乘数的正值。</li><li>每一次累加操作，递减一次乘数。直到乘数的值为零，表示操作结束。</li><li>输出结果根据正负关系取得。</li></ol><p>其实传统的乘法器是很容易的，但是随着整数的出现，负值和正值也随着出现，这也使得设计多了一点难度。但是只要掌握负值和正值的关系以后，乘法只作正值也“无问题” ，只要在结果输出之前“下一点手脚”就行了。</p><h2 id="1-3-传统乘法器的改进"><a href="#1-3-传统乘法器的改进" class="headerlink" title="1.3 传统乘法器的改进"></a>1.3 传统乘法器的改进</h2><p>传统的乘法器虽然简单，但是它有一个致命的问题。就是被乘数越大就越消耗时钟。那么要解决这个问题就要了解为什么会产生这个问题。还是举例来说：</p><p>假设A=10 , B=20 , A x B ，那么时钟的消耗至少需要 20个，因为A值需要累加20次才能得到结果。回顾一下乘法法则：A x B = B x A。如果以B作为基础，那么B值只需要累加10次就能得到结果，这样就可以节省时钟的消耗。</p><p>因此我们可以这样改进：在进行累加操作之前，增加一个比较步骤。如果被乘数小于乘数，那么被乘数和乘数互换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Multiplier , Multiplicand&#125; = Multiplicand &lt; Multiplier ? &#123;Multiplicand ，Multiplier&#125; : &#123;Multiplier ，Multiplicand&#125;；</span><br></pre></td></tr></table></figure></p><p>于是,改进版传统乘法器实现的大致操作如下：</p><ol><li>在初始化之际，取乘数和被乘数的正负关系，然后取被乘数和乘数的正值。</li><li>乘数和被乘数比较，如果被乘数小于乘数，结果乘数和被乘数互换。</li><li>每一次累加操作，递减一次乘数。直到乘数的值为零，表示操作结束。</li><li>输出结果根据正负关系取得。</li></ol><p>传统的乘法器无论如何改进也好，当遇见如 127 x 127 的乘数和被乘数，咋样也看不出什么可以优化的地方…</p><h2 id="1-4-补码的意义"><a href="#1-4-补码的意义" class="headerlink" title="1.4 补码的意义"></a>1.4 补码的意义</h2><p>上面也说到过一点，就是实现正数和负数之间的转换，也就是说使符号位能与有效值部分一起参加运算,从而简化运算规则。</p><p>另外，还有一点就是使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计。</p><h2 id="1-5-Booth算法乘法器"><a href="#1-5-Booth算法乘法器" class="headerlink" title="1.5 Booth算法乘法器"></a>1.5 Booth算法乘法器</h2><hr><h1 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h1>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《9号秘事》</title>
      <link>https://DOOKNET.github.io/2018/02/11/%E5%BD%B1%E8%AF%84/%E3%80%8A9%E5%8F%B7%E7%A7%98%E4%BA%8B%E3%80%8B/</link>
      <guid>https://DOOKNET.github.io/2018/02/11/%E5%BD%B1%E8%AF%84/%E3%80%8A9%E5%8F%B7%E7%A7%98%E4%BA%8B%E3%80%8B/</guid>
      <pubDate>Sun, 11 Feb 2018 07:43:12 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;昨天花了一晚上时间把神剧《9号秘事》的第2、3、4季都刷完了。当看完最后一集时慢慢合上电脑，深深地吸了口气，可以说是非常的爽了。说实话，上一
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天花了一晚上时间把神剧《9号秘事》的第2、3、4季都刷完了。当看完最后一集时慢慢合上电脑，深深地吸了口气，可以说是非常的爽了。说实话，上一次有这种感觉的时候还是看完《黑镜》那会了。</p><p>躺床上后，我迟迟不能入睡，脑子里还处理着剧里的信息。经历各种思考后，我决定把我觉得重要的东西写下来，一来整理下自己的思路，写下自己的观后感，二来当作笔记，生怕时间久后忘了精彩的情节。</p><hr><h1 id="第一季"><a href="#第一季" class="headerlink" title="第一季"></a>第一季</h1><p>[还没看]</p><hr><h1 id="第二季"><a href="#第二季" class="headerlink" title="第二季"></a>第二季</h1><p>首播时间：2015-03-26(英国)</p><p><a href="https://movie.douban.com/subject/26341777/" target="_blank" rel="noopener">豆瓣</a>评分：8.8（截至编辑时间）</p><p><a href="http://www.imdb.com/title/tt4513394/" target="_blank" rel="noopener">IMDb</a>评分：8.2（截至编辑时间）</p><h2 id="第1集"><a href="#第1集" class="headerlink" title="第1集"></a>第1集</h2><p><img src="https://user-images.githubusercontent.com/29295862/36075132-1ab83574-0f85-11e8-9f29-9c54020d4615.png" alt="9号秘事"></p><p><img src="https://user-images.githubusercontent.com/29295862/36075135-201825ce-0f85-11e8-96c0-484ef73fca36.png" alt="9号列车卧铺车厢"></p><ul><li><p><strong>故事概况：</strong></p><p> 秘事发生在一节9号列车卧铺车厢里。医生Maxwell为了得到工作，杀死了恰巧在同一车厢的竞争对手Meyer，但在下车前才发现自己杀错人了，真正的Meyer医生睡错了床，而且在此之前他还得到了Maxwell的帮助。</p></li></ul><p>说实话，第一眼看到男主，我一度以为是《纸牌屋》里的弗兰克，虽然我知道不可能，但实在是太像了，眼神，动作，神态。。。像极了年轻版的弗兰克！另外，英国人的口音实在是让人无法抗拒啊啊啊！！！</p><p><img src="https://user-images.githubusercontent.com/29295862/36075144-4327ce3e-0f85-11e8-9544-128fa5765e97.png" alt="Dr Maxwell"></p><p>咳咳，回到剧情。</p><p>一开始车厢里只有Maxwell医生和一个已经睡着了的人（说实话不是很懂为啥要叫Maxwell这个名字。。。），在Maxwell躺下准备睡觉后，来了一位彪形大汉，虽西装革履，但体态只能说类似流浪汉，吵吵闹闹，莽莽撞撞，而且似乎哪里不舒服，一直咳嗽。Maxwell忍受不了争吵几句过后便各自睡觉去了。不就，来了一对老夫妻，是去参加女儿婚礼的，显然，又是吵吵闹闹。最后进来的是个fat gril，是个旅行家，一直在打电话，一会又出去了。</p><p>到这里，显然这节车厢里的人物都亮相了。说实话，我对接下来的剧情发展毫无头绪。前期导演拍了很多看似无关紧要、乱七八糟的情节（对于细节的把控很是到位，看似纷乱复杂，实则耐人寻味，幽默风趣），但这些情节对人物形象的塑造很是关键，为后面的情节做了很好的铺垫，可以说，缺一不可。【在这里忍不住想夸一下演员的演技了，可以说这部剧里的演员没一个是我觉得帅或者漂亮的，可人家硬是靠演技把人物演活了。反观国内，哎。。。或许某天，等国民消费水平提高了，我们不再买单无脑的肥皂剧了，不再期待闭着眼都能猜到的剧情了，知道自己想要的是什么了，愿意花钱买优质服务了之后，才会有类似HBO、英国电视4台、NetFlix等公司的优秀作品吧。。。】</p><p>情节的反转是在旅行女打完电话后回来开始的，同时，她又带回了个炮友。闲聊了会后，他俩就开始躺床上了（虽然说很多国外高分剧都充斥着暴力、色情等元素，但我至少没有在英剧里见过。额，美剧里倒是不少，特别是HBO的。。。），就在这时，那男的看到上铺的乘客的头悬在床边，惊醒了一车的人。</p><p>说到底就是突然发现自己的车厢中有具尸体，乘客都有啥反应。（额，那我上面为什么要说那么多。。。）其实有趣就有趣在这里，每个人物做出的的反应是如此真实，合情合理，但总感觉略有违和感。先来说医生Maxwell，他首先站出来说都别动，我是医生，在确认那人死后又出去找警卫，让其他人都别走。到这里，都没什么特别的，作为一个医生，这些都是常规操作。其次，说说那个胖叔叔，真正的Meyer医生，他下床后第一件事就是翻死者的口袋，找到了个钱包，里面有张家庭合照。显然，他已经当爷爷了，众人都感到惋惜。这时Maxwell医生回来了，说找不到人。没办法，这时候只能用紧急停止按钮了。</p><blockquote><p>。。。。。。桂桂，怎么写了辣么多了，这才第一集啊，后面怎么办哟。。。算了，后面不写那么详细了，难得写影评没想说的太多没收住。。。先这样吧，下次有空再更——2018/2/11</p></blockquote><h2 id="第2集"><a href="#第2集" class="headerlink" title="第2集"></a>第2集</h2><h2 id="第3集"><a href="#第3集" class="headerlink" title="第3集"></a>第3集</h2><h2 id="第4集"><a href="#第4集" class="headerlink" title="第4集"></a>第4集</h2><h2 id="第5集"><a href="#第5集" class="headerlink" title="第5集"></a>第5集</h2><h2 id="第6集"><a href="#第6集" class="headerlink" title="第6集"></a>第6集</h2>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/11/%E5%BD%B1%E8%AF%84/%E3%80%8A9%E5%8F%B7%E7%A7%98%E4%BA%8B%E3%80%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Matlab产生测试激励</title>
      <link>https://DOOKNET.github.io/2018/02/11/Matlab/Matlab%E4%BA%A7%E7%94%9F%E6%B5%8B%E8%AF%95%E6%BF%80%E5%8A%B1/</link>
      <guid>https://DOOKNET.github.io/2018/02/11/Matlab/Matlab%E4%BA%A7%E7%94%9F%E6%B5%8B%E8%AF%95%E6%BF%80%E5%8A%B1/</guid>
      <pubDate>Sun, 11 Feb 2018 06:44:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在FPGA开发过程中几乎都要用到仿真的功能，对于一些简单的外部激励（如时钟、复位、简单数据或者信号等）直接在testbench中编写产生就行
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在FPGA开发过程中几乎都要用到仿真的功能，对于一些简单的外部激励（如时钟、复位、简单数据或者信号等）直接在testbench中编写产生就行了，但对于复杂的外部激励数据，很难在testbench中产生，这时就要通过读取外部文件里的数据来实现。通过和matlab的配合使用，基本上可以模拟各种外部激励。<br>举例来说：输入信号是三个不同频率的正弦波的相加，经过FIR低通滤波器滤除高频分量，输出频率最低的那个正弦信号。这种情况下测试用的输入信号不能通过testbench编写产生。<br>简单来说有以下两种方法可以模拟输入信号：</p><ol><li>在FPGA内部通过DDS产生三个正弦波，然后将三个波形相加作为输入信号。</li><li>利用matlab产生输入信号，将数据导出为.txt文件，在仿真时读取文件内的数据作为外部激励。</li></ol><p>显然第二种方法更加灵活和便捷。下面，具体介绍一下这种方法的使用。</p><hr><h3 id="平台："><a href="#平台：" class="headerlink" title="平台："></a>平台：</h3><ul><li>Vivado 16.4</li><li>Matlab R2017b</li></ul><h3 id="Matlab程序编写："><a href="#Matlab程序编写：" class="headerlink" title="Matlab程序编写："></a>Matlab程序编写：</h3><ul><li>代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">%=============设置系统参数==============%</span><br><span class="line">f1=1e6;        %设置波形频率</span><br><span class="line">f2=500e3;</span><br><span class="line">f3=800e3;</span><br><span class="line">Fs=20e6;        %设置采样频率</span><br><span class="line">L=1024;         %数据长度</span><br><span class="line">N=14;           %数据位宽</span><br><span class="line">%=============产生输入信号==============%</span><br><span class="line">t=0:1/Fs:(1/Fs)*(L-1);</span><br><span class="line">y1=sin(2*pi*f1*t);</span><br><span class="line">y2=sin(2*pi*f2*t);</span><br><span class="line">y3=sin(2*pi*f3*t);</span><br><span class="line">y4=y1+y2+y3;</span><br><span class="line">y_n=round(y4*(2^(N-3)-1));      %N比特量化;如果有n个信号相加，则设置（N-n）</span><br><span class="line">%=================画图==================%</span><br><span class="line">a=10;           %改变系数可以调整显示周期</span><br><span class="line">stem(t,y_n);</span><br><span class="line">axis([0 L/Fs/a -2^N 2^N]);      %显示</span><br><span class="line">%=============写入外部文件==============%</span><br><span class="line">fid=fopen(&apos;E:\Workspace\Vivado_16.4\TEST\TestBench\sin_data.txt&apos;,&apos;w&apos;);    %把数据写入sin_data.txt文件中，如果没有就创建该文件</span><br><span class="line">for k=1:length(y_n)</span><br><span class="line">    B_s=dec2bin(y_n(k)+((y_n(k))&lt;0)*2^N,N);</span><br><span class="line">    for j=1:N</span><br><span class="line">        if B_s(j)==&apos;1&apos;</span><br><span class="line">            tb=1;</span><br><span class="line">        else</span><br><span class="line">            tb=0;</span><br><span class="line">        end</span><br><span class="line">        fprintf(fid,&apos;%d&apos;,tb);</span><br><span class="line">    end</span><br><span class="line">    fprintf(fid,&apos;\r\n&apos;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fprintf(fid,&apos;;&apos;);</span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure><p>此程序中设置了三个频率分别为1M、500k和800k的正弦波，然后将三个波形相加并且量化后作为输出。最后将路径设置为相应文件所在路径即可，需要注意的是如果对应路径下没有相应文件，则会自动新建文件并写入数据。</p><ul><li><p>运行程序：<br><img src="https://user-images.githubusercontent.com/29295862/35777703-4d3d1e6c-09ed-11e8-9c6f-3b6f9abd597b.png" alt=" "></p></li><li><p>打开对应的文件目录<br><img src="https://user-images.githubusercontent.com/29295862/35777708-51403d82-09ed-11e8-9cbe-41e84d961120.png" alt=" "><br>可以看到二进制数据文件已经生成。</p></li></ul><p>接下来就可以进行在testbench中读取外部数据的操作了。</p><h3 id="Testbench的编写："><a href="#Testbench的编写：" class="headerlink" title="Testbench的编写："></a>Testbench的编写：</h3><ul><li>代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ps</span><br><span class="line"></span><br><span class="line">module TB_readfile();</span><br><span class="line">reg     SCLK;</span><br><span class="line">reg    [13:0]  data_out;</span><br><span class="line"></span><br><span class="line">//--------------时钟部分----------------//</span><br><span class="line">initial     SCLK = 0;</span><br><span class="line">always      #10     SCLK = ~SCLK;</span><br><span class="line"></span><br><span class="line">//-------------------------------------//</span><br><span class="line">parameter data_num = 32&apos;d1024;</span><br><span class="line">integer   i = 0;</span><br><span class="line">reg [13:0]  data_men[1:data_num];</span><br><span class="line">reg [13:0]  data_reg = 0;</span><br><span class="line">initial begin</span><br><span class="line">    $readmemb(&quot;E:/Workspace/Vivado_16.4/2017_8_28_TEST/TestBench/sin_data.txt&quot;,data_men);   //注意斜杠的方向，不能反&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">end</span><br><span class="line">always @(posedge SCLK) begin</span><br><span class="line">    data_out &lt;= data_men[i];</span><br><span class="line">    i &lt;= i + 8&apos;d1;</span><br><span class="line">end</span><br><span class="line">//------------------------------------//</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>因为这里只需要读取外部数据，所以Vivado工程里只需要添加仿真文件就行了。</p><ul><li>运行仿真：<br><img src="https://user-images.githubusercontent.com/29295862/35778030-52933256-09f3-11e8-87fc-56e030b5d9ba.png" alt=" "><br>可以看到，仿真的波形和matlab中显示的波形一致，说明结果正确。</li></ul><hr><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>Matlab可以说是个很强大的工具，在设计中合理的使用matlab可以起到事半功倍的效果。当然我也在不断的学习中，如果有疑问或者更好的想法欢迎交流。。。</p>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/11/Matlab/Matlab%E4%BA%A7%E7%94%9F%E6%B5%8B%E8%AF%95%E6%BF%80%E5%8A%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AM解调的FPGA实现</title>
      <link>https://DOOKNET.github.io/2018/02/09/FPGA/AM%E8%A7%A3%E8%B0%83%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</link>
      <guid>https://DOOKNET.github.io/2018/02/09/FPGA/AM%E8%A7%A3%E8%B0%83%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Fri, 09 Feb 2018 11:13:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;一、说明：&quot;&gt;&lt;a href=&quot;#一、说明：&quot; class=&quot;headerlink&quot; title=&quot;一、说明：&quot;&gt;&lt;/a&gt;一、说明：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;功能：AM解调&lt;/li&gt;
&lt;li&gt;平台：Vivado 2016.4 和 Matlab R2017a&lt;/l
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一、说明："><a href="#一、说明：" class="headerlink" title="一、说明："></a>一、说明：</h2><ol><li>功能：AM解调</li><li>平台：Vivado 2016.4 和 Matlab R2017a</li></ol><h2 id="二、原理："><a href="#二、原理：" class="headerlink" title="二、原理："></a>二、原理：</h2><h3 id="1-AM解调原理"><a href="#1-AM解调原理" class="headerlink" title="1.AM解调原理"></a>1.AM解调原理</h3><ul><li><p><strong>模拟电路中采用“包络检波”的方法：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35344975-615af3f6-0169-11e8-9d69-7cac3196baad.png" alt="这里写图片描述"></p></li><li><p><strong>数字电路中采用类似的方法：</strong><br>先将已调信号取绝对值，再经过低通滤波器，滤除高频分量（经AM调制的信号包含两个高频分量：载波频率+/-调制信号频率，因此低通滤波器的截止频率小于两个高频分量就可以），得到的就是叠加了直流分量的调制信号，去直流后便可以得到调制信号。</p></li></ul><h2 id="三、AM解调的FPGA实现"><a href="#三、AM解调的FPGA实现" class="headerlink" title="三、AM解调的FPGA实现"></a>三、AM解调的FPGA实现</h2><h3 id="1-将已调制的AM信号取绝对值"><a href="#1-将已调制的AM信号取绝对值" class="headerlink" title="1.将已调制的AM信号取绝对值"></a>1.将已调制的AM信号取绝对值</h3><p>关于AM信号的产生，参见上一篇博客：<a href="http://blog.csdn.net/hooknet/article/details/79129451" target="_blank" rel="noopener">AM调制的FPGA实现</a></p><p>简单说明一下对数据取反的思路：如果是无符号数，则不存在符号位，也就是说数据都是正数，不需要取绝对值；如果是有符号数，通过检测最高位的符号位，如果符号位是1，则表示数据是负数，对数据取反，如果符号位是0，则表示数据是正数，不需要取反操作。</p><ul><li><strong>取绝对值的Verilog实现：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">data_tdata &lt;= 0;</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 1)begin</span><br><span class="line">data_tdata &lt;= -&#123;AM_mod&#125;;//如果符号位是1，对数据取反</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 0)begin</span><br><span class="line">data_tdata &lt;= AM_mod;//如果符号位是0，数据不变</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">data_tdata &lt;= data_tdata;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="2-使用FIR滤波器滤除高频分量"><a href="#2-使用FIR滤波器滤除高频分量" class="headerlink" title="2.使用FIR滤波器滤除高频分量"></a>2.使用FIR滤波器滤除高频分量</h3><p>关于Vivado的FIR IP核可以说是功能很强大的，但这里不需要其他复杂的功能，只需要简单的生成一个的低通滤波器就行了。<br>类似于ROM核的生成，配置FIR同样需要Matlab配合。可见，Matlab的功能是多么强大。这里Matlab的主要作用是对滤波器的性能进行仿真并生成相应的抽头系数。</p><ul><li><p><strong>使用Matlab生成FIR的抽头系数</strong></p><p>在Matlab的命令行窗口输入：<strong>filterDesigner</strong>（以前是用fdatool命令，不过输入fdatool也可以，只是会提醒你改用新的命令）弹出滤波器设计窗口：<br><img src="https://user-images.githubusercontent.com/29295862/35436554-d89264fc-02c9-11e8-86a7-1a3ec42b38a4.png" alt=" "></p><p>接下来，对滤波器的一些参数进行设置：<br><img src="https://user-images.githubusercontent.com/29295862/35436558-dfcb81c2-02c9-11e8-9645-53b557b1e4dc.png" alt=" "></p><p>参数设置好后，点击<strong>Design Filter</strong> 按钮查看生成滤波器的幅频响应图，通过幅频响应等图来判断滤波器是否达到设计要求：<br><img src="https://user-images.githubusercontent.com/29295862/35436563-e5e15244-02c9-11e8-9182-5dfec6896191.png" alt=" "></p><p>设计的滤波器满足性能指标后需要将抽头系数导出，保存为.coe文件。在导出前需要对系数进行量化。因为需要解调的AM信号也是16位宽，所以这里的位宽设置保持默认值，这些可以根据实际情况自行修改。<br><img src="https://user-images.githubusercontent.com/29295862/35436570-eb25ca28-02c9-11e8-8883-bb954ca2632c.png" alt=" "></p><p>量化过后就能将抽头系数导出为.coe文件了：<br><img src="https://user-images.githubusercontent.com/29295862/35436572-ed8ba742-02c9-11e8-950d-d837242dc0c8.png" alt=" "></p></li><li><p><strong>生成FIR IP核</strong></p><p>IP核的具体配置如下：<br><img src="https://user-images.githubusercontent.com/29295862/35437697-9211cfe0-02ce-11e8-8952-72d5271b127f.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35437699-927806de-02ce-11e8-97fa-89c4f899561c.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35437700-92dc2ed4-02ce-11e8-8ba7-9b9bb82c8b15.png" alt=" "></p><p>其他保持默认即可：<br><img src="https://user-images.githubusercontent.com/29295862/35437701-933df1dc-02ce-11e8-854a-abd7a0fb4038.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35437702-93c467f8-02ce-11e8-8c03-142055f69c5e.png" alt=" "></p><p>同样，在IP核配置界面也可以查看滤波器的幅频特性：<br><img src="https://user-images.githubusercontent.com/29295862/35437703-942511ac-02ce-11e8-94e0-809114c09697.png" alt=" "></p></li></ul><p>IP核生成完毕后，就可以编写IP核的调用模块了。</p><ul><li><strong>FIR IP核调用模块：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module FIR_Control(</span><br><span class="line">inputclk,</span><br><span class="line">inputrst_n,</span><br><span class="line">inputsigned[15:0]s_axis_data_tdata,</span><br><span class="line">outputreg [7:0]data_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">wire s_axis_data_tready;</span><br><span class="line">wirem_axis_data_tvalid;</span><br><span class="line">wire [39:0]m_axis_data_tdata;//滤波器输出信号</span><br><span class="line"></span><br><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">data_out &lt;= 0;</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">data_out &lt;= m_axis_data_tdata[33:26];//根据仿真结果进行截位</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//--------------调用FIR核----------------//</span><br><span class="line">FIRFIR_inst0(</span><br><span class="line">  .aclk(clk),</span><br><span class="line">  .s_axis_data_tvalid(1),//拉高时IP核开始工作</span><br><span class="line">  .s_axis_data_tready(s_axis_data_tready),</span><br><span class="line">  .s_axis_data_tdata(s_axis_data_tdata),//输入信号</span><br><span class="line">  .m_axis_data_tvalid(m_axis_data_tvalid),//拉高时表明数据输出有效</span><br><span class="line">  .m_axis_data_tdata(m_axis_data_tdata)//输出信号</span><br><span class="line">);</span><br><span class="line">//---------------------------------------//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>需要注意的是：<br><strong>m_axis_data_tdata</strong> 信号是滤波器的数据输出信号，我们在使用时一般都要对此数据进行截位操作，如何进行截位需要根据仿真结果来确定。比如，在这个工程中，我需要的滤波器的输出数据是8位，但不能一下子截取高8位，而且<strong>m_axis_data_tdata</strong>是个40位的数据，从仿真波形来看<strong>m_axis_data_tdata</strong>[39:34]都是符号位，因此从33位开始往下截取8位数据（当然也可以从34位开始截，这样的话就多了一位符号位，相应的数据位就变少了一位）。</p><h3 id="3-去直流处理"><a href="#3-去直流处理" class="headerlink" title="3.去直流处理"></a>3.去直流处理</h3><p>经过FIR滤波后的波形其实就是一个叠加了直流分量的调制信号。在本工程中，AM调制是100%调制，也就是说解调时经过FIR后的信号的最小值为0，可以把它看作是无符号的数，直接经DA输出就行了。<br>如果不是100%调制呢？也就是说解调时经过FIR后的信号的最小值是大于0的，那么这个大于0的量就相当于直流，需要去掉后再经DA输出。<br>因此，在这个工程中，不需要去直流处理。下面给出顶层文件的代码。</p><ul><li><strong>顶层模块编写：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">module TOP(</span><br><span class="line">inputclk,</span><br><span class="line">inputrst_n,</span><br><span class="line">output[7:0]AM_demod</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//--------------------------------//</span><br><span class="line">reg signed[15:0]data_tdata;</span><br><span class="line">wire signed[15:0]AM_mod;</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">//-----------取绝对值-------------//</span><br><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">data_tdata &lt;= 0;</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 1)begin</span><br><span class="line">data_tdata &lt;= -&#123;AM_mod&#125;;//如果符号位是1，对数据取反</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 0)begin</span><br><span class="line">data_tdata &lt;= AM_mod;//如果符号位是0，数据不变</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">data_tdata &lt;= data_tdata;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">//-----------AM已调信号------------//</span><br><span class="line">modulatemodulate_inst0(</span><br><span class="line">.clk(clk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.AM_mod(AM_mod)</span><br><span class="line">);</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">//----------滤波器控制模块---------//</span><br><span class="line">FIR_ControlFIR_Control_inst2(</span><br><span class="line">.clk(clk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.s_axis_data_tdata(data_tdata),</span><br><span class="line">.data_out(AM_demod)</span><br><span class="line">);</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="4-解调仿真"><a href="#4-解调仿真" class="headerlink" title="4.解调仿真"></a>4.解调仿真</h3><ul><li><strong>编写TestBeach：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ps</span><br><span class="line"></span><br><span class="line">module tb_AM();</span><br><span class="line"></span><br><span class="line">//===================解调部分====================//</span><br><span class="line">//----------接口设置----------//</span><br><span class="line">reg sclk;</span><br><span class="line">regrst_n;</span><br><span class="line">wire [7:0]AM_demod;</span><br><span class="line">//--------------------------//</span><br><span class="line">initialsclk = 1;</span><br><span class="line">always#5sclk = ~sclk;//100M时钟</span><br><span class="line"></span><br><span class="line">initialbegin</span><br><span class="line">rst_n = 0;</span><br><span class="line">#500</span><br><span class="line">rst_n = 1;</span><br><span class="line">end</span><br><span class="line">//----------解调模块----------//</span><br><span class="line">TOPTOP_inst(</span><br><span class="line">.clk(sclk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.AM_demod(AM_demod)</span><br><span class="line">);</span><br><span class="line">//---------------------------//</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><ul><li><p><strong>仿真结果</strong></p><p><img src="https://user-images.githubusercontent.com/29295862/35448887-7a2c7452-02f6-11e8-91ce-0253953ac892.png" alt=" "></p></li></ul><p>由仿真结果可知，最终输出信号正确还原了已调制信号的包络，表明解调正确。</p>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/09/FPGA/AM%E8%A7%A3%E8%B0%83%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
